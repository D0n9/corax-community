# Q&A

**Q: 有哪些因素影响分析精度？**

A: 分析精度不仅受`核心分析引擎`的分析算法影响，**也受用户的输入参数配置影响**，目前大致有如下原因：

1. runtime classes 的提供是否完整，二进制是否存在混淆等（需要用户辅助解决）

2. 运行命令参数配置存在问题

3. 规则检查器的代码质量及配置中的各种参数

4. 核心分析引擎本身的算法精度和一些分析限制（必要的在时间和内存上的妥协）



**Q: 为什么分析需要编译源码后的产物？**

A:  在静态分析技术实现上，纯源码分析往往需要先将其转换为 AST（抽象语法树），对于 JVM 上运行的语言（Java、Kotlin、JSP、Scala 和 Groovy 等）都需要分别设计一对一的语言前端来解析，AST 又包含了各种各样复杂的语言特性和各种版本上的语法糖，这将严重增加分析引擎的负担，并且这不是静态分析的侧重点，所以往往 java 静态分析都会采用直接或者间接的方式分析 JVM字节码（即各种形式的编译产物 class） 来获得程序的操作语义信息。

一方面，源码分析需要各种语言环境和依赖，比如有 `import package.a.*;`如果环境没有 `package.a` 这个包，那么所有引用了该包下的声明都将因必要的依赖信息不完整导致解析失败或者丢失分析精度。

另一方面就是使用源码分析，将极大地限制静态分析的使用场景，比如想要分析一个不带源码的二进制包。

​      最后，源码分析只能分析源码，而二三方库绝大多数是没有源码的，依赖源码的分析器在处理跨模块调用(存在过程间调用)分析时，会因为没有源码而导致分析链路断掉，比如source sink或者传播污点的方法在三方库中时，依赖源码的分析方案就会产生大量漏报。

​      所以往往来说，分析 class 能比分析源码得到更高精度的报告。 

**Q: 为什么分析需要源码？**

A: 源码不是必须提供的，只是为了更好地展示缺陷报告，以及在使用 `--auto-app-classes` 参数时候可以用来辅助分析器根据源码来匹配对应的 classes 以获知哪些类是项目类哪些是库类，这将帮助分析器更清楚分析的侧重点，简化参数的配置。

**Q: 为什么使用kotlin?**


A: kotlin 编写的代码更简单易懂，能极高提升开发者开发效率，易于维护；并且很难出现头疼的 `NullPointerException` 问题。kotlin 还支持协程异步执行，极高地提升了分析器效率；另外 kotlin 支持更多的语法特性，让我们更多的时间花费在算法本身而不是浪费在编程上：)，有木有心动？好吧！当然您仍然可以编写 java 代码并和 kotlin 代码放在一起混合调用，无需另外做任何事。



